// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"
	repository "oolio-assignment/pkg/repository"

	mock "github.com/stretchr/testify/mock"
)

// CrudRepo is an autogenerated mock type for the CrudRepo type
type CrudRepo struct {
	mock.Mock
}

// CreateOrder provides a mock function with given fields: ctx, orderID, couponCode, orders, products
func (_m *CrudRepo) CreateOrder(ctx context.Context, orderID string, couponCode string, orders []byte, products []byte) error {
	ret := _m.Called(ctx, orderID, couponCode, orders, products)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrder")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []byte, []byte) error); ok {
		r0 = rf(ctx, orderID, couponCode, orders, products)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateProduct provides a mock function with given fields: ctx, req
func (_m *CrudRepo) CreateProduct(ctx context.Context, req *repository.ProductModel) (string, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateProduct")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *repository.ProductModel) (string, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *repository.ProductModel) string); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *repository.ProductModel) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProduct provides a mock function with given fields: ctx, page, limit
func (_m *CrudRepo) GetProduct(ctx context.Context, page string, limit string) ([]repository.ProductModel, error) {
	ret := _m.Called(ctx, page, limit)

	if len(ret) == 0 {
		panic("no return value specified for GetProduct")
	}

	var r0 []repository.ProductModel
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]repository.ProductModel, error)); ok {
		return rf(ctx, page, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []repository.ProductModel); ok {
		r0 = rf(ctx, page, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repository.ProductModel)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, page, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProductByProductID provides a mock function with given fields: ctx, productID
func (_m *CrudRepo) GetProductByProductID(ctx context.Context, productID int) (repository.ProductModel, error) {
	ret := _m.Called(ctx, productID)

	if len(ret) == 0 {
		panic("no return value specified for GetProductByProductID")
	}

	var r0 repository.ProductModel
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (repository.ProductModel, error)); ok {
		return rf(ctx, productID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) repository.ProductModel); ok {
		r0 = rf(ctx, productID)
	} else {
		r0 = ret.Get(0).(repository.ProductModel)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, productID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewCrudRepo creates a new instance of CrudRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCrudRepo(t interface {
	mock.TestingT
	Cleanup(func())
}) *CrudRepo {
	mock := &CrudRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
